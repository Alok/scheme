First Steps: Compiling and running
------------

```bash
# Example Bash code
$ stack build
```

```haskell
-- Example Haskell code
main :: IO ()
main = return ()
```

## Version 2 changes
We are the version 2.0 of https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/
https://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf
-- Monad Transformers for language evaluation, lexical scoping, IO, error handling    
`
-- Removal of 'IORef' and 'read' function    
-- Pretty Print for viewing parsed language structure    


## Organization
####Main.hs    
currently runs the Repl, should convert into file evaluator
####Repl.hs
defines the repl 
####Parser.hs    
parsec parsing
####Eval.hs      
contains evaluation function, environmental setting fns  
####LispVal.hs    
defines LispVal
#### Prims.hs
defines the std lib, depends Eval
####Pretty.hs    
pretty printer, pdoc?

## 1.1 Lisp and its lists
Lisp is a list processing language. That means every expression is essentially a list. 
Each list, say `(+ 1 2)` is evaluated, and reduced. Whenever a list is encounter, it
is evaluated. This doesn't always make sense, say `(1 2 3)` where encountered, evaluating
it would be non-sensical. For this reason, `quote` or `'` is used. Now if we evaluate
something like `'(1 2 3)` or `(quote (1 2 3))` we get `(1 2 3)`. Essentially, this just delays evaluation, 
and lets us use the Haskell list data structure for internal representation of data structures. (See Haskell wiki)

## 1.2 List manipulation
There are three basic functions for manipulating these structures in our Scheme.     
`car`  ... `(car '(1 2 3))` => `(1)`   
`cadr` ... `(cadr '(1 2 3))` => `(2 3)`    
`cons` ... `(cons 1 '(2 3))` => `(1 2 3)`    

## Stages of interpretation
User Inputs code and data in text format.    
Conversion of text files to manipulatable representation in Haskall.     
Evaluate or "run" the internal structure. 
Return the value to the user. 
<The Assumptions we make about the invariance of the real world influencing the returned value for a given expression
determine how we can model this process in Haskall through its IO system. 

## 1.3 Internal representation, welcome to LispVal

When creating a programming language, we need a way to represent the structure of a program 
that can be manipulated within Haskell. Haskell has been gifted with a great type system that allows for pattern
matching on data constructors. When we go to evaluate our internal language structure, one function can be easily be dispatched
different ways for the same type. 
The Haskell type we are going to use to represent lisp values is aptly named `LispVal`, they represent Lisp
S-Expressions, variable names, and primitive types like Number or String. Since Lisp represents code and data with the
same structures, so too will we.   
.Together with our monadic evaluation strategy, they will build our language.
`data LispVal = DataConstructor InternalHaskellType` is the pattern used to define primitive
lisp values, like `Double` or `String`, the `List` data structure, {keywords like `lambda`
or `define`) and importantly variable or `Atom` names, like `x`.  
For our Scheme, a LispVal will represent a Scheme S-Expression before, and after evaluation. 
This simplifies implementation, and lets us do things like delay evaluation and allow 
users to define functions that can be evaluated into Scheme functions for later use, 
since data and code are represented using the same internal structure and Haskell type.
However, we need to be super careful about when things get evaluated and when they dont 
when environmental variables are involved. The benefit is extreme a concise evalutator
and  flexibility: programs come in as a LispVal, and results are returned as a LispVal. 
Structure Interpretation of Computer Programs is a great source for showing how this
approach can do complex tasks through a simple system.  Once we can reckon 
homoiconicity with the Haskell type system, the program and its result will always be the same type of object. 

To provide a basic development tool, `showVal` is a function that maps LispVals to 
Text string for showing the user internal values. The `show` typeclass is also 
derivided for `LispVal`, and will be an important tool when debugging the parser. 

To be useful, `LispVal` must map from user input. This process is called parsing, 
and is the first source of `LispVal` types. The next source of `LispVal` types are 
those derived from other `LispVal`s, and are generated by `eval`. `LispVal`s also
represent saved variables that can be recalled. This changing set of saved `LispVal`s
is the environment, and a variables availability is called its `scope`. 

When there is an error evalutating `LispVal`'s, a another data type, `LispError`, is
generated to describe what went wrong. 


## Define LispVal


## Next, Parsers!

##Chapters, v1.0
01_introduction.md    
02_parsing.md    
03_evaluation.md    
04_errors.md    
05_primitives.md    
06_repl.md    
07_mutation.md    
08_closures.md    
09_io.md    
10_stdlib.md    
11_conclusion.md    


##Chapters, v2.0
#### in progress
01_introduction.md    
02_parsing.md    
03_evaluation.md    
04_primitives.md    
05_repl.md    
06_errors.md    

#### future
07_mutation.md    
08_closures-and-scopes.md    
09_io.md    
10_stdlib.md    
11_conclusion.md    


